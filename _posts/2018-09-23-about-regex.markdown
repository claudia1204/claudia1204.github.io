---
layout: post
title:  "about regex"
date:   2018-09-22 16:29:41 +0800
categories: test
---
关于正则
------------------------

正则组成
=======
普通字符        +     元字符
a-z,A-z,0-9,_        \ ^ $ . ？ * + | {n} {m,n} (pattern) (?:pattern) (?!pattern) (?=pattern)  [] [^] \b


元字符详细
=======

| 字符        | 描述      |  
| --------   | -----:  |
|\        | 标记下一个字符为特殊字符/原义字符/向后引用/八进制转义符。e.g. \n 代表换行符
|^        | 匹配输入字符串开始位置。如果加了RegeXP的Miltiline属性，^ 也匹配\n或者\r之后的位置。 ^ss 代表字符串以ss开始
|$        | 匹配输入字符串的结束位置。如果加了RegeXP的Miltiline属性，^ 也匹配\n或者\r之前的位置。
|.        | 匹配单个任意字符，除了\n。 可使用[.\n]匹配任意字符
|?        | 匹配前面的表达式或者字符的0次或者1次。等价于{0,1}。e.g. test(as)+ 可以匹配test或者是testas.  testa+ 可以匹配test或者testa。<br/> 备注：当?跟在次数限定符（*，+，？，{m,n},{n}）后面时，匹配模式是非贪婪的，即尽可能少匹配所搜索的字符串。<br>e.g. 'o+?' 将只会匹配'hellooooo'中的单个'o'而不是'ooooo'
|*        | 匹配前面的表达式的0次或者多次。 等价于{0,}。
|+        | 匹配前面的表达式的1次或者多次。等价于{1,}。
||        | 匹配两边表达式。<br>e.g. test|hello \d\d, 等价于 (test|hello \d\d)，因此只会匹配'test 22'中的test以及匹配'hello 22'中的'hello 22'. 如果想要匹配'test 22'则可用括号限定两边的表达式，例如(test|hello) \d\d.
|{n}        |匹配前面表达式n次
|{m,n}      |匹配前面表达式最小m次，最多n次，m<=n
|(.....)    |匹配.....且获取匹配.....的结果。将括号中的表达式作为一个分组，匹配后可根据$index,index为该分组的序号可获取该匹配结果。例如$5
|(?:.....)  |匹配.....但不存储匹配结果。将括号中的表达式作为一个分组，匹配后无法根据$index获取结果，为非获取匹配
|(?=.....)  |正向预查（肯定顺序环视）。从左往右在匹配.....字符串,且不消耗匹配字符。<br/>如'windows(?=2000)',则匹配windows2000中的windows，但是不匹配windows300中的windows。。
|(?<.....)    |肯定逆序环视。同上，方向为从右往左。
|(?!.....)  |负向预查。在任何不匹配.....的字符串开始处匹配查找字符串。 如'wdinwos (?!2000)',代表获取'window '字符串且该字符串必须满足后面不带'2000'.<br/>备注，此匹配不消耗该预查字符.....，即下一次搜索会window空格后开始查找。
|(?<!.....)  |否定逆序环视。
|[....]           |匹配在字符集合....里的单个字符。例如Chapter [123]，可以匹配Chapter 1， Chapter 2。 如果希望表示范围的话可以用[1-5]，此时表示匹配1-5内的任意单个数字。
|[^....]     |匹配不在字符集合....里的单个字符。例如Chater [^123],可以匹配Chater 4，但是不能匹配Chapter 1
|\b         |匹配单词边界。例如never say never，可以用ver\b 匹配never中的verb 。

优先级
======
转义符 > ()、[]  > 限定符 > 位置和顺序 > |


Python分组使用--命名分组
=================
(?P<name>) 其中name代表该分组的另外一个别名
<code>
	s = 'debug 10:01:01 11:11:11:hello word'
	import re
	time = re.search(r'debug\s(?P<time>\d+:\d+:\d+\s\d+:\d+:\d+):.*', s).group('time')
	print(time)	
</code>

result: 10:01:01 11:11:11




 



